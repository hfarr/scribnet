---
layout: note.njk
title: Testing
---

<editor-hf style="white-space: pre-wrap;">
  <!-- <div class="htmlrender"> -->
    <h1>Title! what in the <em>heck</em> are all these demo pages for?</h1>
    <p>This document exists to easily construct objects for unit testing!</p>
    <p>Featuring a couple of cool paragraphs, <strong>inline elements,</strong> <strong><em>nested</em> line
        elements,</strong> and so much more!</p>
    <p>Well, not "so much" more. Just enough to tell me if there are problems! Like maybe some utf-16 ðŸ˜€ pretty glad
      vscode supports unicode code points...</p>
    <h2>We've got headers too</h2>
    <p>I think this is alright for a <em>standard</em> document experience. Don't you?</p>
  <!-- </div> -->
</editor-hf>

<stack-l id="toolmark">
</stack-l>
<div style="display: flex;">
  <button id="select">Select</button>|
  <button id="bold">Bold</button>|
  <button id="italic">Italic</button>
</div>
<div style="display: flex;">
  <button id="togbold">Toggle Bold</button>|
  <button id="togitalic">Toggle Italic</button>
</div>
<button id="bug">Low key, (used to be) a bug. No more.</button>

<!-- <script type="module" src="js/modules/document/DOM.mjs"></script> -->
<script>
  const hf = document.querySelector('editor-hf')
  let editor, ed
  const toolmark = document.querySelector("#toolmark")

  function label(fragments, ...values) {
    let result = ""
    for (let i = 0; i < values.length; i++) {
      result += `<strong>${fragments[i].trim()}:</strong>&nbsp;${values[i]}<br>`
    }
    return result
  }

  // TODO I'd like all the p's in a collapsible, or maybe arrange them in collapsibles.
  // like p1, p2 could be side by side in a flex arrangement and the flex container could
  // be collapsible. Right now my layout is not too composable, since I've shifted my
  // attention over to the editor capabilities
  const p1 = document.createElement('p')  // Label for DOM state
  // const p2 = document.createElement('p')  // Label for EditDoc state
  const p3 = document.createElement('p')  // EditRenderer
  const d4 = document.createElement('div')  // html render
  const d5 = document.createElement('div')
  toolmark.append(p3)
  // p3.style = 'white-space: pre-wrap;'


  let htmlRender


  window.addEventListener('load', async (event) => {
    editor = hf.editor
    /* Two notions for renderes. Independent ones, and ones attached to an editor.
      There can be multiple or 0 independent renderers, and right now we're
      constructing software to allow exactly one renderer, specifically an HTML
      renderer, for the editor component. Eventually such restrictions won't
      apply to that either, where we could have multiple or 0 renderes there too.
      Or maybe for simplicity we won't. Maybe each editor will only have one
      renderer. But Editors can share documents.
      What's the difference then?
      Indepdent renders would use the below to receive all events from the document
    
        htmlRender.setEditDoc(editor.currentDocument)
    
      whereas renders attached to editors won't always re-render. Only when the
      editor decides they should. That's a tricky bit but I think it can still
      work. It's what I'm going to do first, and we'll iterate to uncover the
      next steps, whether either of the proposed ideas above or something else.
    */

    // initial renders

    import('/js/scribnet/document/Renderer.mjs').then(m => {
      const { EditRenderer, HTMLRenderer } = m
      editDocRender = new EditRenderer()
      editDocRender.setWrapper(p3)
      editDocRender.setEditDoc(editor.currentDocument)
      editDocRender.render(editor.currentDocument)

      htmlRender = new HTMLRenderer()
      // htmlRender.setWrapper(document.querySelector('.htmlrender'))
      // htmlRender.setWrapper(hf)
      hf.defaultRenderer = htmlRender
      htmlRender.render(editor.currentDocument)

      ed = editor.currentDocument
    })

    hf.editor.addListener('selectionchange', (editor) => {
      const cursor = editor.cursor
      const selection = editor.selectedText.length > 0 ? editor.selectedText : editor.characterAtCursor
      p1.innerHTML = label`DOM Offset ${cursor} DOM Selection ${selection} Length ${selection.length}`
    })

    document.querySelector("#select").onclick = () => { editor.select(69, 96) }
    document.querySelector("#bold").onclick = () => { editor.setBold() }
    document.querySelector("#italic").onclick = () => { editor.setItalic() }
    document.querySelector('#togbold').addEventListener('click', ()=>{ editor.toggleBold() })
    document.querySelector('#togitalic').addEventListener('click', ()=>{ editor.toggleItalic() })
    document.querySelector("#bug").onclick = () => { editor.select(96, 165), editor.toggleBold() }

  })


</script>