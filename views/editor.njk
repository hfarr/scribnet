---
layout: note.njk
title: Editing
---


<editor-hf>
  <h1>Title title title <em>And now, a word from our sponsor</em></h1><p>
       &nbsp;
  </p><p>
&nbsp;
  </p><p>

      
  </p>
  <p></p>
  <p>Uselessly  spaced    out

    maybe even &nbsp; like this
  </p>
  <p>Hi. Here is some <strong>Bold text! </strong><strong><em>Bold and italicized!</em> bold </strong>
    <strong>back to bold...</strong>
  </p>
  <h2>section</h2>
  <p>blessed are these &lt;p&gt;</p>
  <p>Hey! edge case <span> more like‚Äîedge SPACE</span></p>
  <p><span>want to see even edgier space? </span><span> yeah you do you-</span></p>
  <p><span>WATCH OUT CURVE</span><span> ball</span></p>
  <p><span>egads.</span>   <span>ball</span></p>
  <p>Seems we've &nbsp;&nbsp;  &nbsp; no choice</p>
  <h2>second section</h2>
  <p>A serious paragraph</p>
  <p>A trial of inline <span>&nbsp;</span></p>
  <p>Space after </p>
  <p>
    A long bit of text. 
    
    See, it's rather unfortunate that we don't write like this
    often. The DOM will take this chunk of text. I think it should keep it within
    the same paragraph. Sometimes it will rearrange HTML for you. It is rather
    forgiving of the input it accepts, such as mixing tags that would normally
    be separated into different elements.

  </p>
  <!-- <pre> -->
    <!-- mehumbra     5 -->
    <!-- <em>bla   h!</em> -->
  <!-- </pre> -->
  <p>
    I could (and probably should) nest my header tags. Accessibility wise I think it
    reads the same as the "flattened" kind where all these elements are next to each
    other. My document model might produce html that's nested which will be useful
    for querying the headers when I eventually make my list element.
  </p>
  <h2>Conclusion</h2>
  <p>
    Hello, üåê!
  </p>
  <p>
    Here our sample text adventure comes to an end. I haven't decided whether I want to
    permit the natural edit events from <span>contentEditable</span> to take their
    natural course or if I'd prefer to interrupt each event and re-render each time. It
    is easy to let the browser do the work but I'll have to take interrupts regardless.
    I want to identify what I'd need to supplement with code.
  </p>
</editor-hf>

<div id="toolmark">
  <p>
    toolmark
  </p>
</div>

<!-- Even HTML breaks it down to separate blocks. Which means we can probably leave it
in the editor, though I'd prefer to.. do better I suppose.
Am I building out a full AST?
 -->

<!-- <script type="module" src="js/modules/document/DOM.mjs"></script> -->
<script>
  const hf = document.querySelector('editor-hf')
  const toolmark = document.querySelector("#toolmark")
  // let mo = await import("/js/modules/document/DOM.mjs")
  const tgt = hf.querySelector('h2')

  function label(fragments, ...values) {
    let result = ""
    for (let i = 0; i < values.length; i++) {
      result += `<strong>${fragments[i].trim()}:</strong>&nbsp;${values[i]}<br>`
    }
    return result
  }

  import("/js/modules/document/DOM.mjs").then( m=> {
    let { renderedText } = m
    document.addEventListener('selectionchange', (sce) => {
      const sel = window.getSelection()
      const re = sel.getRangeAt(0)  // Not handling multi ranges for now

      let startOffset = renderedText(hf, re.startContainer).length + re.startOffset - re.startContainer.textContent.length;
      let endOffset = renderedText(hf, re.endContainer).length + re.endOffset - re.endContainer.textContent.length;
      let focusOffset = renderedText(hf, sel.focusNode).length + sel.focusOffset - sel.focusNode.textContent.length;
      let charUnderCursor = hf.innerText.codePointAt(focusOffset)
      let selectedText = hf.innerText.slice(startOffset, endOffset)
      if (selectedText.length == 0) {
        selectedText = charUnderCursor ? String.fromCodePoint(charUnderCursor) : '-'
      }

      // TODO get an html escaper for selectedText if we want to spit it out 'raw'. Maybe.. an "escape" component
      // TODO work out a way to handle ctrl-a. I think it 'selects' hf-editor which breaks the tree traversal (yields undefined)
      toolmark.querySelector('p').innerHTML = label`Offset ${focusOffset} Length ${endOffset - startOffset} Character ${selectedText}`

    })

    let { treeFoldr } = m
    const processText = async () => {
      let rightmostChild = treeFoldr((cur, prev) => {
        if (prev) return prev;
        if (/\S/.test(cur.textContent)) {
          return cur
        }
        return undefined
      }, undefined, hf)
      return renderedText(hf, rightmostChild);
    }

    document.addEventListener('DOMContentLoaded', async (event) => {
      let text = await processText()
      console.debug("!", text === hf.innerText, "!")
    })

    return m
  }).then( m=>{
    let { treeTraverse, treeFoldr } = m

    function pruneTo(node) {
      return nodeOther => {
        if (nodeOther === node) return true;
        return node.compareDocumentPosition(nodeOther) & (Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINS)
      }
    }

    let pred = pruneTo(tgt.firstChild)
    // console.debug(treeFoldr((cur, prev) => pred(cur) ? [cur,...prev] : prev, [], hf))

    const f = (node, children) => {
      if (node.tagName) {
        return `${node.tagName} ${children}`
      } else {
        return node.textContent
      }
      // return undefined
    }

    // need to work out traversing so that it accepts the same fold structure, in a manner of speaking.
    // right now we can't touch the internals on how fold works, we cannot re-use any code that works
    // with treeFoldr although we should be able to. But we can mimic a clone of sorts, its just less
    // convenient because treeTraverse yields a different set of capabilities than fold.
    // More powerful but inflexible, which I dont think has to be the case.
    const traveler = (node, children, childrenNodes) => {
      if (pred(node)) {
        children = children.filter(Boolean)
        // normal function
        // ------
        return f(node,children, childrenNodes)
        // ----
      }
      return undefined // base :S
    }

    // console.debug(treeTraverse(traveler, hf))
  })


</script>