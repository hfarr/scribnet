---
layout: note.njk
title: Editing
---


<editor-hf>
</editor-hf>

<!-- Even HTML breaks it down to separate blocks. Which means we can probably leave it
in the editor, though I'd prefer to.. do better I suppose.
Am I building out a full AST?
 -->

<script type="module">
  import { Block as EditBlock, Atom, HTMLRenderer } from "/js/modules/document/document.mjs"

  let hf = document.querySelector('editor-hf');
  console.log("Edit doc:", hf.editDoc)


  {# import("/js/modules/document/document.mjs")
  .then((module) => { #}
    {# let {Block: EditBlock, Atom, HTMLRenderer } = module #}
    console.log(EditBlock)

    let doc = hf['editDoc']

    doc.blocks.push(
      new EditBlock('h1',
        new Atom([], "Title title title"),
        new Atom(['italic'], " And now a word from our sponsor")
      ),
      new EditBlock('p',
        new Atom([], "Hi. Here is some"),
        new Atom(['bold'], "Bold Text! "),
        new Atom(['bold', 'italic'], "bold and italicized. "),
        new Atom(['bold'], "back to bold..."),
        new Atom(['bold', 'italic'], "beHOLD!"),
        new Atom([], "boring")
      ),
      new EditBlock('h2',
        new Atom([], "subsection"),
      ),
      new EditBlock('p', 
        new Atom([], 'blessed are these &lt;p&gt;')
      ),
      new EditBlock('h2',
        new Atom([], "subsection"),
      ),
      new EditBlock('p',
        new Atom([], "Time to get serious."),
      ),
      new EditBlock('p',
        new Atom([], "Here is a long line. It is an entire paragraph. For sure. It needs to be lonker than 65 characters for me to test out the wrapping we'll get. So here we are. enjoy."),
      ),
    )

    hf.editDoc.appendAt(5, "!aaa!")
    hf.render()
    {# console.debug(hf.editDoc) #}

    /* 
      I think, by default, I will have it attach an HTML renderer for the custom element.
      It does make sense to me that an "editor" has knowledge it needs to render as such.
      I'm bothered slightly but I can't articulate clearly the reason why, which is no
      reason at all as far as I am concerned right now.
      */
    {# let renderer = new HTMLRenderer();
    let renderedDoc = renderer.render(hf.editDoc)
    console.log(renderedDoc)
    hf.innerHTML = renderedDoc; #}

    // RENDER DOC ON EDITTT
    // listener I guess. that's easier yknow?

  {# }) #}
  
  hf.listeners.push(
    editor => hf.innerHTML = renderer.render(editor.editDoc)
  )

</script>
<script>
  function scoop(node, childs) {
    return [{n:node}, childs]
  }
  function cat(node, childs) {
    return [node, ...childs]
  }
  function treeFoldr(f, base, tree) {
    // console.debug('treefoldr', tree, tree.childNodes)

    if (tree.childNodes === undefined || tree.childNodes.length === 0) {
      return f(tree, base)
    } 

    const apply = (func, arg) => {
      console.debug("apply", arg, func)
      return x => treeFoldr(f, func(arg), x)
    }
    const kiddos = [...tree.childNodes]
    console.debug('Kiddos:', kiddos)

    return kiddos.reduce(apply, x => f(x, base))
  }
</script>