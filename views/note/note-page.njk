---
layout: note
pagination:
  data: notes
  size: 1
  alias: noteItem
permalink: "note/{{ noteItem.name | slug }}/"
---
{# only permalink and eleventyComputed can contain variables/shortcodes in this frontmatter format (and Im not sure I can work out pagination with a ---js frontmatter at the moment) #}
{# title: "{{ noteItem.name | slug }}" #}
{# eleventyComputed: #}

{# 
  This file, combined with note.11tydata.js, using data
  computed from _data/notes.js, populates the note/
  directory in the site output with note data from the
  server. It is fetched at build time.
  We could have this file in the root, because the 
  permalink frontmatter data sets it to the note/ 
  directory. The idea though is to group related information
  together. Perhaps if we didn't need a note.11tydata.js, or
  weren't planning an index page, then we might do that.
#}

{# Set header <title> here using note name #}
{# <h1> #}
{# <h1>Name: {{ noteItem.name }}</h1> #}
{# <h2>Whoa</h2> #}
{# <h2>{{ noteItem | access("name") }}</h2> #}

{# resourceName is computed. noteItem.name is provided by _data/notes.js #}
<!-- <h2>{{ resourceName }}</h2> -->
<h2>{{ noteItem.name }}</h2>

{# later on this link might only appear in certain circumstances, based on what the server provides #}
{# heck, it might even just drop-in add an editor-hf wrapping the contents - we have some options. #}
{# I'm not sure I mind going to a different route or not, maybe I like the option to do that but also
  have a component in place that can update in-place. Only available if you have permissions.
  TODO iDEA for later 
  #}
<a id="edit-button" href="/edit/{{ noteItem.name | slug }}">Edit</a>
<a id="view-button" href="/note/{{ noteItem.name | slug }}">View</a>
<!-- <a id="edit-button" onclick="return false;" href="#">Edit</a> -->
<!-- <button id="edit-button" -->
<br>
<!-- <div id="doc" data=""></div> -->
<div id="content" style="white-space: pre-wrap;">{{ noteItem.content | safe }}</div>

<!-- <script type="module" src="/js/scribnet/document/Renderer.mjs"></script> -->
<script>
  // const resourceName = window.location.pathname.match(/[^\/]*$/)[0] // grabs the string in the url past the last forward slash
  const resourceName = "{{ noteItem.name }}"
  const slugName = "{{ noteItem.name | slug }}"
  console.debug(resourceName)

  const contentWrapper = document.querySelector("#content")
  const editButton = document.querySelector("#edit-button")
  const viewButton = document.querySelector("#view-button")

  const url = "/api/graphql"

  const query = (content,variables) => {

    const requestBody = {
      query: content, 
      variables: variables ?? null
    }
    const options = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      // body: JSON.stringify(requestBody)
      body: JSON.stringify(requestBody)
    }

    return fetch(url, options)
  }
  
  const saveContent = async data => {
  // const saveHTML = async content => {
    // likely, a function that "saves html" would first render it into html rather than assume "content" is html. so we'll call it saveContent for now

    return await query(`mutation { updateNote(name: "${resourceName}", input: { data: ${JSON.stringify(JSON.stringify(data))} }) { name } } `)
  }

  // Toggle functionality- opportunity for a component. TODO

  const applyState = () => {
    const { currentState = "viewing" } = window.history.state ?? {}
    viewButton.removeAttribute("style")
    editButton.removeAttribute("style")
    switch(currentState) {
      case "editing": {
        
        const editor = document.createElement("editor-hf")
        editor.setAttribute("style", "white-space: pre-wrap;")  // auto part of editor? :S. use that shadow dom?
        editor.append(...contentWrapper.childNodes)
        contentWrapper.after(editor)
        contentWrapper.parentNode.removeChild(contentWrapper)

        // contentWrapper.

        import('/js/scribnet/document/Renderer.mjs').then(m => {
          const { HTMLRenderer } = m;
          htmlRenderer = new HTMLRenderer()
          editor.defaultRenderer = htmlRenderer
          editor.render()
          // htmlRenderer.render(editor.editor.currentDocument)

          editor.editor.currentDocument.addSelectListener(doc => {
            // yeah it's still /too much/ to submit updates eagerly, owing to the fact that 
            // some triggers of this command don't even update content (it's a "select" listener).
            // Naming is wrong too really it should just be "addListener" because it listens for
            // nearly all state changes of an EditDocument.
            const data={ content: htmlRenderer.toHTML(doc) }
            return saveContent(data)
          })
        })

        editButton.setAttribute("style", "display: none;")
        break;
      }
      case "viewing": {
        const editor = document.querySelector("editor-hf")
        if (editor !== null) {
          contentWrapper.append(...editor.childNodes)
          editor.after(contentWrapper)
          editor.parentNode.removeChild(editor)  // unnecessary, but eh.
        }
      }
      default: {
        viewButton.setAttribute("style", "display: none;")
      }
    }
  }

  const transitionState = (newState, url) => {
    window.history.pushState({ currentState: newState }, undefined, url )
    applyState()
  }

  window.onpopstate = (event) => {
    console.log("State (pop event)", event.state)
    applyState()
  }

  // setState - pushes context for a state
  // engageState - set page to display current state

  function engageEditMode() {

    // TODO: Handle onpopstate to elegantly "reset" the page to the '/note/'
    window.history.pushState({ currentState: "editing" }, undefined, `/edit/${slugName}`)
    // window.history.pushState({ count: ((window.history.state?.count ?? 0) + 1) }, undefined, `/edit/${slugName}`)
    applyState()
  }
  function engageViewMode() {
    
    window.history.pushState({ currentState: "viewing" }, undefined, `/note/${slugName}`)
    applyState()
  }

  editButton.addEventListener("click", (evt) => { 
    evt.preventDefault(); 
    engageEditMode(); 
  })
  viewButton.addEventListener("click", (evt) => {
    evt.preventDefault()
    engageViewMode();
  })

  applyState()

</script>